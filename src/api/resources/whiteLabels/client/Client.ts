/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as AirweaveSDK from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace WhiteLabels {
    export interface Options {
        environment?: core.Supplier<environments.AirweaveSDKEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        /** Override the X-API-Key header */
        apiKey?: core.Supplier<string | undefined>;
        /** Override the X-Organization-ID header */
        organizationId?: core.Supplier<string | undefined>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the X-API-Key header */
        apiKey?: string | undefined;
        /** Override the X-Organization-ID header */
        organizationId?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class WhiteLabels {
    protected readonly _options: WhiteLabels.Options;

    constructor(_options: WhiteLabels.Options = {}) {
        this._options = _options;
    }

    /**
     * List all white label integrations for your organization.
     *
     * <br/><br/>
     * Returns all custom OAuth integrations configured with your own branding and
     * credentials. These integrations allow you to present OAuth consent screens with
     * your company name instead of Airweave.<br/><br/>**White label integrations only
     * work with OAuth2.0 sources** like Slack, Google Drive, or HubSpot that require
     * OAuth consent flows.
     *
     * @param {WhiteLabels.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.whiteLabels.listWhiteLabels()
     */
    public listWhiteLabels(
        requestOptions?: WhiteLabels.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.WhiteLabel[]> {
        return core.HttpResponsePromise.fromPromise(this.__listWhiteLabels(requestOptions));
    }

    private async __listWhiteLabels(
        requestOptions?: WhiteLabels.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.WhiteLabel[]>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                "white-labels/list",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "X-API-Key": requestOptions?.apiKey,
                    "X-Organization-ID": requestOptions?.organizationId,
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.WhiteLabel[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError("Timeout exceeded when calling GET /white-labels/list.");
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new white label integration.
     *
     * <br/><br/>
     * **This only works for sources that use OAuth2.0 authentication** like Slack,
     * Google Drive, GitHub, or HubSpot.<br/><br/>Sets up a custom OAuth integration
     * using your own OAuth application credentials and branding. Once created,
     * customers will see your company name during OAuth consent flows instead of
     * Airweave. This requires you to have already configured your own OAuth
     * application with the target service provider.
     *
     * @param {AirweaveSDK.WhiteLabelCreate} request
     * @param {WhiteLabels.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.whiteLabels.createWhiteLabel({
     *         name: "Customer Portal Slack Integration",
     *         source_short_name: "slack",
     *         redirect_url: "https://yourapp.com/auth/slack/callback",
     *         client_id: "1234567890.1234567890123",
     *         client_secret: "abcdefghijklmnopqrstuvwxyz123456",
     *         allowed_origins: "https://yourapp.com,https://app.yourapp.com"
     *     })
     */
    public createWhiteLabel(
        request: AirweaveSDK.WhiteLabelCreate,
        requestOptions?: WhiteLabels.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.WhiteLabel> {
        return core.HttpResponsePromise.fromPromise(this.__createWhiteLabel(request, requestOptions));
    }

    private async __createWhiteLabel(
        request: AirweaveSDK.WhiteLabelCreate,
        requestOptions?: WhiteLabels.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.WhiteLabel>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                "white-labels",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "X-API-Key": requestOptions?.apiKey,
                    "X-Organization-ID": requestOptions?.organizationId,
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.WhiteLabel, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError("Timeout exceeded when calling POST /white-labels.");
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve a specific white label integration by its ID.
     *
     * @param {string} whiteLabelId - The unique identifier of the white label integration
     * @param {WhiteLabels.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.whiteLabels.getWhiteLabel("white_label_id")
     */
    public getWhiteLabel(
        whiteLabelId: string,
        requestOptions?: WhiteLabels.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.WhiteLabel> {
        return core.HttpResponsePromise.fromPromise(this.__getWhiteLabel(whiteLabelId, requestOptions));
    }

    private async __getWhiteLabel(
        whiteLabelId: string,
        requestOptions?: WhiteLabels.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.WhiteLabel>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `white-labels/${encodeURIComponent(whiteLabelId)}`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "X-API-Key": requestOptions?.apiKey,
                    "X-Organization-ID": requestOptions?.organizationId,
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.WhiteLabel, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling GET /white-labels/{white_label_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update a white label integration's configuration.
     *
     * @param {string} whiteLabelId - The unique identifier of the white label integration to update
     * @param {AirweaveSDK.WhiteLabelUpdate} request
     * @param {WhiteLabels.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.whiteLabels.updateWhiteLabel("white_label_id", {
     *         name: "Updated Customer Portal Integration",
     *         redirect_url: "https://v2.yourapp.com/auth/slack/callback",
     *         allowed_origins: "https://v2.yourapp.com,https://api.yourapp.com"
     *     })
     */
    public updateWhiteLabel(
        whiteLabelId: string,
        request: AirweaveSDK.WhiteLabelUpdate = {},
        requestOptions?: WhiteLabels.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.WhiteLabel> {
        return core.HttpResponsePromise.fromPromise(this.__updateWhiteLabel(whiteLabelId, request, requestOptions));
    }

    private async __updateWhiteLabel(
        whiteLabelId: string,
        request: AirweaveSDK.WhiteLabelUpdate = {},
        requestOptions?: WhiteLabels.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.WhiteLabel>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `white-labels/${encodeURIComponent(whiteLabelId)}`,
            ),
            method: "PUT",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "X-API-Key": requestOptions?.apiKey,
                    "X-Organization-ID": requestOptions?.organizationId,
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.WhiteLabel, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling PUT /white-labels/{white_label_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete a white label integration.
     *
     * <br/><br/>
     * Permanently removes the white label configuration and OAuth credentials.
     * Existing source connections created through this integration will continue to work,
     * but no new OAuth flows can be initiated until a new white label integration is created.
     *
     * @param {string} whiteLabelId - The unique identifier of the white label integration to delete
     * @param {WhiteLabels.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.whiteLabels.deleteWhiteLabel("white_label_id")
     */
    public deleteWhiteLabel(
        whiteLabelId: string,
        requestOptions?: WhiteLabels.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.WhiteLabel> {
        return core.HttpResponsePromise.fromPromise(this.__deleteWhiteLabel(whiteLabelId, requestOptions));
    }

    private async __deleteWhiteLabel(
        whiteLabelId: string,
        requestOptions?: WhiteLabels.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.WhiteLabel>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `white-labels/${encodeURIComponent(whiteLabelId)}`,
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "X-API-Key": requestOptions?.apiKey,
                    "X-Organization-ID": requestOptions?.organizationId,
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.WhiteLabel, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling DELETE /white-labels/{white_label_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Generate a branded OAuth2 authorization URL for customer authentication.
     *
     * <br/><br/>
     * Creates the OAuth consent URL that customers should be redirected to for
     * authentication. The OAuth consent screen will display your company name and
     * branding instead of Airweave.
     *
     * @param {string} whiteLabelId - The unique identifier of the white label integration
     * @param {WhiteLabels.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.whiteLabels.getWhiteLabelOauth2AuthUrl("white_label_id")
     */
    public getWhiteLabelOauth2AuthUrl(
        whiteLabelId: string,
        requestOptions?: WhiteLabels.RequestOptions,
    ): core.HttpResponsePromise<string> {
        return core.HttpResponsePromise.fromPromise(this.__getWhiteLabelOauth2AuthUrl(whiteLabelId, requestOptions));
    }

    private async __getWhiteLabelOauth2AuthUrl(
        whiteLabelId: string,
        requestOptions?: WhiteLabels.RequestOptions,
    ): Promise<core.WithRawResponse<string>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `white-labels/${encodeURIComponent(whiteLabelId)}/oauth2/auth_url`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "X-API-Key": requestOptions?.apiKey,
                    "X-Organization-ID": requestOptions?.organizationId,
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as string, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling GET /white-labels/{white_label_id}/oauth2/auth_url.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * List all source connections created through a specific white label integration.
     *
     * <br/><br/>
     * Returns source connections that were established using this white label's OAuth flow.
     *
     * @param {string} whiteLabelId - The unique identifier of the white label integration
     * @param {WhiteLabels.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.whiteLabels.listWhiteLabelSourceConnections("white_label_id")
     */
    public listWhiteLabelSourceConnections(
        whiteLabelId: string,
        requestOptions?: WhiteLabels.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnectionListItem[]> {
        return core.HttpResponsePromise.fromPromise(
            this.__listWhiteLabelSourceConnections(whiteLabelId, requestOptions),
        );
    }

    private async __listWhiteLabelSourceConnections(
        whiteLabelId: string,
        requestOptions?: WhiteLabels.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnectionListItem[]>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `white-labels/${encodeURIComponent(whiteLabelId)}/source-connections`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "X-API-Key": requestOptions?.apiKey,
                    "X-Organization-ID": requestOptions?.organizationId,
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as AirweaveSDK.SourceConnectionListItem[],
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling GET /white-labels/{white_label_id}/source-connections.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Complete the OAuth flow and create a source connection.
     *
     * <br/><br/>
     * **This is the core endpoint that converts OAuth authorization codes into working
     * source connections.**<br/><br/>The OAuth credentials are obtained automatically
     * from the authorization code - you do not need to provide auth_fields. The white
     * label integration is automatically linked to the created source connection for
     * tracking and branding purposes.
     *
     * @param {string} whiteLabelId - The unique identifier of the white label integration
     * @param {AirweaveSDK.BodyExchangeWhiteLabelOauth2CodeWhiteLabelsWhiteLabelIdOauth2CodeOptions} request
     * @param {WhiteLabels.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.whiteLabels.exchangeWhiteLabelOauth2CodeWhiteLabelsWhiteLabelIdOauth2CodeOptions("white_label_id", {
     *         code: "4/P7q7W91a-oMsCeLvIaQm6bTrgtp7"
     *     })
     */
    public exchangeWhiteLabelOauth2CodeWhiteLabelsWhiteLabelIdOauth2CodeOptions(
        whiteLabelId: string,
        request: AirweaveSDK.BodyExchangeWhiteLabelOauth2CodeWhiteLabelsWhiteLabelIdOauth2CodeOptions,
        requestOptions?: WhiteLabels.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnection> {
        return core.HttpResponsePromise.fromPromise(
            this.__exchangeWhiteLabelOauth2CodeWhiteLabelsWhiteLabelIdOauth2CodeOptions(
                whiteLabelId,
                request,
                requestOptions,
            ),
        );
    }

    private async __exchangeWhiteLabelOauth2CodeWhiteLabelsWhiteLabelIdOauth2CodeOptions(
        whiteLabelId: string,
        request: AirweaveSDK.BodyExchangeWhiteLabelOauth2CodeWhiteLabelsWhiteLabelIdOauth2CodeOptions,
        requestOptions?: WhiteLabels.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnection>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `white-labels/${encodeURIComponent(whiteLabelId)}/oauth2/code`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    "X-API-Key": requestOptions?.apiKey,
                    "X-Organization-ID": requestOptions?.organizationId,
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnection, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling POST /white-labels/{white_label_id}/oauth2/code.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }
}
