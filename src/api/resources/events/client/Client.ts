/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as AirweaveSDK from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace Events {
    export interface Options {
        environment?: core.Supplier<environments.AirweaveSDKEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    }
}

/**
 * API endpoints for managing webhook subscriptions and event messages. Subscribe to events like sync completions to receive real-time notifications at your webhook URL
 */
export class Events {
    protected readonly _options: Events.Options;

    constructor(_options: Events.Options) {
        this._options = _options;
    }

    /**
     * Retrieve all event messages for your organization.
     *
     * Event messages represent webhook payloads that were sent (or attempted to be sent)
     * to your subscribed endpoints. Each message contains the event type, payload data,
     * and delivery status information.
     *
     * Use the `event_types` query parameter to filter messages by specific event types,
     * such as `sync.completed` or `sync.failed`.
     *
     * @param {AirweaveSDK.GetMessagesEventsMessagesGetRequest} request
     * @param {Events.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.events.getMessages()
     */
    public getMessages(
        request: AirweaveSDK.GetMessagesEventsMessagesGetRequest = {},
        requestOptions?: Events.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.EventMessage[]> {
        return core.HttpResponsePromise.fromPromise(this.__getMessages(request, requestOptions));
    }

    private async __getMessages(
        request: AirweaveSDK.GetMessagesEventsMessagesGetRequest = {},
        requestOptions?: Events.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.EventMessage[]>> {
        const { event_types: eventTypes } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (eventTypes != null) {
            if (Array.isArray(eventTypes)) {
                _queryParams["event_types"] = eventTypes.map((item) => item);
            } else {
                _queryParams["event_types"] = eventTypes;
            }
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                "events/messages",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.EventMessage[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError("Timeout exceeded when calling GET /events/messages.");
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve a specific event message by its ID.
     *
     * Returns the full message details including the event type, payload data,
     * timestamp, and delivery channel information. Use this to inspect the
     * exact payload that was sent to your webhook endpoints.
     *
     * Use `include_attempts=true` to also retrieve delivery attempts for this message,
     * which include HTTP response codes, response bodies, and timestamps for debugging
     * delivery failures.
     *
     * @param {string} messageId - The unique identifier of the message to retrieve (UUID).
     * @param {AirweaveSDK.GetMessageEventsMessagesMessageIdGetRequest} request
     * @param {Events.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.events.getMessage("550e8400-e29b-41d4-a716-446655440000", {
     *         include_attempts: true
     *     })
     */
    public getMessage(
        messageId: string,
        request: AirweaveSDK.GetMessageEventsMessagesMessageIdGetRequest = {},
        requestOptions?: Events.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.EventMessageWithAttempts> {
        return core.HttpResponsePromise.fromPromise(this.__getMessage(messageId, request, requestOptions));
    }

    private async __getMessage(
        messageId: string,
        request: AirweaveSDK.GetMessageEventsMessagesMessageIdGetRequest = {},
        requestOptions?: Events.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.EventMessageWithAttempts>> {
        const { include_attempts: includeAttempts } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (includeAttempts != null) {
            _queryParams["include_attempts"] = includeAttempts.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `events/messages/${encodeURIComponent(messageId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.EventMessageWithAttempts, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling GET /events/messages/{message_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * List all webhook subscriptions for your organization.
     *
     * Returns all configured webhook endpoints, including their URLs, subscribed
     * event types, and current status (enabled/disabled). Use this to audit
     * your webhook configuration or find a specific subscription.
     *
     * @param {Events.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.events.getSubscriptions()
     */
    public getSubscriptions(
        requestOptions?: Events.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.WebhookSubscription[]> {
        return core.HttpResponsePromise.fromPromise(this.__getSubscriptions(requestOptions));
    }

    private async __getSubscriptions(
        requestOptions?: Events.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.WebhookSubscription[]>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                "events/subscriptions",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.WebhookSubscription[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError("Timeout exceeded when calling GET /events/subscriptions.");
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new webhook subscription.
     *
     * Webhook subscriptions allow you to receive real-time notifications when events
     * occur in Airweave. When you create a subscription, you specify:
     *
     * - **URL**: The HTTPS endpoint where events will be delivered
     * - **Event Types**: Which events you want to receive (e.g., `sync.completed`, `sync.failed`)
     * - **Secret** (optional): A custom signing secret for verifying webhook signatures
     *
     * After creation, Airweave will send HTTP POST requests to your URL whenever
     * matching events occur. Each request includes a signature header for verification.
     *
     * @param {AirweaveSDK.CreateSubscriptionRequest} request
     * @param {Events.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.events.createSubscription({
     *         url: "https://api.mycompany.com/webhooks/airweave",
     *         event_types: ["sync.completed", "sync.failed"]
     *     })
     */
    public createSubscription(
        request: AirweaveSDK.CreateSubscriptionRequest,
        requestOptions?: Events.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.WebhookSubscription> {
        return core.HttpResponsePromise.fromPromise(this.__createSubscription(request, requestOptions));
    }

    private async __createSubscription(
        request: AirweaveSDK.CreateSubscriptionRequest,
        requestOptions?: Events.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.WebhookSubscription>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                "events/subscriptions",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.WebhookSubscription, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError("Timeout exceeded when calling POST /events/subscriptions.");
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve a specific webhook subscription with its recent delivery attempts.
     *
     * Returns the subscription configuration along with a history of message delivery
     * attempts. This is useful for debugging delivery issues or verifying that your
     * endpoint is correctly receiving events.
     *
     * Use `include_secret=true` to also retrieve the signing secret for webhook
     * signature verification. Keep this secret secure.
     *
     * @param {string} subscriptionId - The unique identifier of the subscription to retrieve (UUID).
     * @param {AirweaveSDK.GetSubscriptionEventsSubscriptionsSubscriptionIdGetRequest} request
     * @param {Events.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.events.getSubscription("550e8400-e29b-41d4-a716-446655440000", {
     *         include_secret: true
     *     })
     */
    public getSubscription(
        subscriptionId: string,
        request: AirweaveSDK.GetSubscriptionEventsSubscriptionsSubscriptionIdGetRequest = {},
        requestOptions?: Events.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.WebhookSubscription> {
        return core.HttpResponsePromise.fromPromise(this.__getSubscription(subscriptionId, request, requestOptions));
    }

    private async __getSubscription(
        subscriptionId: string,
        request: AirweaveSDK.GetSubscriptionEventsSubscriptionsSubscriptionIdGetRequest = {},
        requestOptions?: Events.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.WebhookSubscription>> {
        const { include_secret: includeSecret } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (includeSecret != null) {
            _queryParams["include_secret"] = includeSecret.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `events/subscriptions/${encodeURIComponent(subscriptionId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.WebhookSubscription, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling GET /events/subscriptions/{subscription_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Permanently delete a webhook subscription.
     *
     * Once deleted, Airweave will stop sending events to this endpoint immediately.
     * This action cannot be undone. Any pending message deliveries will be cancelled.
     *
     * If you want to temporarily stop receiving events, consider disabling the
     * subscription instead using the PATCH endpoint.
     *
     * @param {string} subscriptionId - The unique identifier of the subscription to delete (UUID).
     * @param {Events.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.events.deleteSubscription("550e8400-e29b-41d4-a716-446655440000")
     */
    public deleteSubscription(
        subscriptionId: string,
        requestOptions?: Events.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.WebhookSubscription> {
        return core.HttpResponsePromise.fromPromise(this.__deleteSubscription(subscriptionId, requestOptions));
    }

    private async __deleteSubscription(
        subscriptionId: string,
        requestOptions?: Events.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.WebhookSubscription>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `events/subscriptions/${encodeURIComponent(subscriptionId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.WebhookSubscription, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling DELETE /events/subscriptions/{subscription_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update an existing webhook subscription.
     *
     * Use this endpoint to modify a subscription's configuration. You can:
     *
     * - **Change the URL**: Update where events are delivered
     * - **Update event types**: Modify which events trigger notifications
     * - **Enable/disable**: Temporarily pause delivery without deleting the subscription
     * - **Recover messages**: When re-enabling, optionally recover missed messages
     *
     * Only include the fields you want to change. Omitted fields will retain their
     * current values.
     *
     * When re-enabling a subscription (`disabled: false`), you can optionally provide
     * `recover_since` to automatically retry all messages that were generated while
     * the subscription was disabled.
     *
     * @param {string} subscriptionId - The unique identifier of the subscription to update (UUID).
     * @param {AirweaveSDK.PatchSubscriptionRequest} request
     * @param {Events.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.events.patchSubscription("550e8400-e29b-41d4-a716-446655440000")
     */
    public patchSubscription(
        subscriptionId: string,
        request: AirweaveSDK.PatchSubscriptionRequest = {},
        requestOptions?: Events.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.WebhookSubscription> {
        return core.HttpResponsePromise.fromPromise(this.__patchSubscription(subscriptionId, request, requestOptions));
    }

    private async __patchSubscription(
        subscriptionId: string,
        request: AirweaveSDK.PatchSubscriptionRequest = {},
        requestOptions?: Events.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.WebhookSubscription>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `events/subscriptions/${encodeURIComponent(subscriptionId)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.WebhookSubscription, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling PATCH /events/subscriptions/{subscription_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retry failed message deliveries for a webhook subscription.
     *
     * Triggers a recovery process that replays all failed messages within the
     * specified time window. This is useful when:
     *
     * - Your endpoint was temporarily down and you want to catch up
     * - You've fixed a bug in your webhook handler
     * - You want to reprocess events after re-enabling a disabled subscription
     *
     * Messages are retried in chronological order. Successfully delivered messages
     * are skipped; only failed or pending messages are retried.
     *
     * @param {string} subscriptionId - The unique identifier of the subscription to recover messages for (UUID).
     * @param {AirweaveSDK.RecoverMessagesRequest} request
     * @param {Events.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.events.recoverFailedMessages("550e8400-e29b-41d4-a716-446655440000", {
     *         since: "2024-03-14T00:00:00Z"
     *     })
     */
    public recoverFailedMessages(
        subscriptionId: string,
        request: AirweaveSDK.RecoverMessagesRequest,
        requestOptions?: Events.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.RecoveryTask> {
        return core.HttpResponsePromise.fromPromise(
            this.__recoverFailedMessages(subscriptionId, request, requestOptions),
        );
    }

    private async __recoverFailedMessages(
        subscriptionId: string,
        request: AirweaveSDK.RecoverMessagesRequest,
        requestOptions?: Events.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.RecoveryTask>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `events/subscriptions/${encodeURIComponent(subscriptionId)}/recover`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.RecoveryTask, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling POST /events/subscriptions/{subscription_id}/recover.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | undefined>> {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
