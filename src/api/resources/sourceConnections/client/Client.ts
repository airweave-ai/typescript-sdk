/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as AirweaveSDK from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace SourceConnections {
    export interface Options {
        environment?: core.Supplier<environments.AirweaveSDKEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

/**
 * API endpoints for managing live connections to data sources. Source connections are the actual configured instances that Airweave uses to sync data from your apps and databases, transforming it into searchable, structured information within collections
 */
export class SourceConnections {
    protected readonly _options: SourceConnections.Options;

    constructor(_options: SourceConnections.Options) {
        this._options = _options;
    }

    /**
     * List source connections across your organization.
     *
     * By default, returns ALL source connections from every collection in your
     * organization. Use the 'collection' parameter to filter results to a specific
     * collection. This is useful for getting an overview of all your data sources
     * or managing connections within a particular collection.
     *
     * @param {AirweaveSDK.ListSourceConnectionsGetRequest} request
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.sourceConnections.list()
     */
    public list(
        request: AirweaveSDK.ListSourceConnectionsGetRequest = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnectionListItem[]> {
        return core.HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
    }

    private async __list(
        request: AirweaveSDK.ListSourceConnectionsGetRequest = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnectionListItem[]>> {
        const { collection, skip, limit } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (collection != null) {
            _queryParams["collection"] = collection;
        }

        if (skip != null) {
            _queryParams["skip"] = skip.toString();
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                "source-connections",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as AirweaveSDK.SourceConnectionListItem[],
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError("Timeout exceeded when calling GET /source-connections.");
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new source connection to sync data into your collection.
     *
     * **This endpoint only works for sources that do not use OAuth2.0.**
     * Sources that do use OAuth2.0 like Google Drive, Slack, or HubSpot must be
     * connected through the UI where you can complete the OAuth consent flow
     * or using Auth Providers (see [Auth Providers](/docs/auth-providers)).<br/><br/>
     *
     * Credentials for a source have to be provided using the `auth_fields` field.
     * Currently, it is not automatically checked if the provided credentials are valid.
     * If they are not valid, the data synchronization will fail.<br/><br/>
     *
     * Check the documentation of a specific source (for example
     * [Github](https://docs.airweave.ai/docs/connectors/github)) to see what kind
     * of authentication is used.
     *
     * @param {AirweaveSDK.SourceConnectionCreate} request
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.sourceConnections.create({
     *         name: "Production Stripe Account",
     *         short_name: "stripe"
     *     })
     */
    public create(
        request: AirweaveSDK.SourceConnectionCreate,
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnection> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: AirweaveSDK.SourceConnectionCreate,
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnection>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                "source-connections",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnection, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError("Timeout exceeded when calling POST /source-connections.");
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve a specific source connection by its ID.
     *
     * @param {string} sourceConnectionId - The unique identifier of the source connection
     * @param {AirweaveSDK.GetSourceConnectionsSourceConnectionIdGetRequest} request
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.sourceConnections.get("source_connection_id")
     */
    public get(
        sourceConnectionId: string,
        request: AirweaveSDK.GetSourceConnectionsSourceConnectionIdGetRequest = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnection> {
        return core.HttpResponsePromise.fromPromise(this.__get(sourceConnectionId, request, requestOptions));
    }

    private async __get(
        sourceConnectionId: string,
        request: AirweaveSDK.GetSourceConnectionsSourceConnectionIdGetRequest = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnection>> {
        const { show_auth_fields: showAuthFields } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (showAuthFields != null) {
            _queryParams["show_auth_fields"] = showAuthFields.toString();
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnection, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling GET /source-connections/{source_connection_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update a source connection's properties.
     *
     * Modify the configuration of an existing source connection including its name,
     * authentication credentials, configuration fields, sync schedule, or source-specific settings.
     *
     * @param {string} sourceConnectionId - The unique identifier of the source connection to update
     * @param {AirweaveSDK.SourceConnectionUpdate} request
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.sourceConnections.update("source_connection_id")
     */
    public update(
        sourceConnectionId: string,
        request: AirweaveSDK.SourceConnectionUpdate = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnection> {
        return core.HttpResponsePromise.fromPromise(this.__update(sourceConnectionId, request, requestOptions));
    }

    private async __update(
        sourceConnectionId: string,
        request: AirweaveSDK.SourceConnectionUpdate = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnection>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}`,
            ),
            method: "PUT",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnection, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling PUT /source-connections/{source_connection_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete a source connection and all associated data.
     *
     * Permanently removes the source connection configuration and credentials.
     * By default, previously synced data remains in your destination systems for continuity.
     * Use delete_data=true to also remove all associated data from destination systems.
     *
     * @param {string} sourceConnectionId - The unique identifier of the source connection to delete
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.sourceConnections.delete("source_connection_id")
     */
    public delete(
        sourceConnectionId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnection> {
        return core.HttpResponsePromise.fromPromise(this.__delete(sourceConnectionId, requestOptions));
    }

    private async __delete(
        sourceConnectionId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnection>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}`,
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnection, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling DELETE /source-connections/{source_connection_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Manually trigger a data sync for this source connection.
     *
     * Starts an immediate synchronization job that extracts fresh data from your source,
     * transforms it according to your configuration, and updates the destination systems.
     * The job runs asynchronously and endpoint returns immediately with tracking information.
     *
     * @param {string} sourceConnectionId - The unique identifier of the source connection to sync
     * @param {AirweaveSDK.BodyRunSourceConnectionsSourceConnectionIdRunPost} request
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.sourceConnections.run("source_connection_id")
     */
    public run(
        sourceConnectionId: string,
        request: AirweaveSDK.BodyRunSourceConnectionsSourceConnectionIdRunPost = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnectionJob> {
        return core.HttpResponsePromise.fromPromise(this.__run(sourceConnectionId, request, requestOptions));
    }

    private async __run(
        sourceConnectionId: string,
        request: AirweaveSDK.BodyRunSourceConnectionsSourceConnectionIdRunPost = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnectionJob>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}/run`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnectionJob, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling POST /source-connections/{source_connection_id}/run.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * List all sync jobs for a source connection.
     *
     * Returns the complete history of data synchronization jobs including successful syncs,
     * failed attempts, and currently running operations.
     *
     * @param {string} sourceConnectionId - The unique identifier of the source connection
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.sourceConnections.listJobs("source_connection_id")
     */
    public listJobs(
        sourceConnectionId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnectionJob[]> {
        return core.HttpResponsePromise.fromPromise(this.__listJobs(sourceConnectionId, requestOptions));
    }

    private async __listJobs(
        sourceConnectionId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnectionJob[]>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}/jobs`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnectionJob[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling GET /source-connections/{source_connection_id}/jobs.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get detailed information about a specific sync job.
     *
     * @param {string} sourceConnectionId - The unique identifier of the source connection
     * @param {string} jobId - The unique identifier of the sync job
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.sourceConnections.getJob("source_connection_id", "job_id")
     */
    public getJob(
        sourceConnectionId: string,
        jobId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnectionJob> {
        return core.HttpResponsePromise.fromPromise(this.__getJob(sourceConnectionId, jobId, requestOptions));
    }

    private async __getJob(
        sourceConnectionId: string,
        jobId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnectionJob>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}/jobs/${encodeURIComponent(jobId)}`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnectionJob, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling GET /source-connections/{source_connection_id}/jobs/{job_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Cancel a running sync job.
     *
     * Sends a cancellation signal to stop an in-progress data synchronization.
     * The job will complete its current operation and then terminate gracefully.
     * Only jobs in 'created', 'pending', or 'in_progress' states can be cancelled.
     *
     * @param {string} sourceConnectionId - The unique identifier of the source connection
     * @param {string} jobId - The unique identifier of the sync job to cancel
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     *
     * @example
     *     await client.sourceConnections.cancelJob("source_connection_id", "job_id")
     */
    public cancelJob(
        sourceConnectionId: string,
        jobId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnectionJob> {
        return core.HttpResponsePromise.fromPromise(this.__cancelJob(sourceConnectionId, jobId, requestOptions));
    }

    private async __cancelJob(
        sourceConnectionId: string,
        jobId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnectionJob>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}/jobs/${encodeURIComponent(jobId)}/cancel`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnectionJob, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as AirweaveSDK.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling POST /source-connections/{source_connection_id}/jobs/{job_id}/cancel.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
