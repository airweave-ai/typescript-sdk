/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as AirweaveSDK from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace SourceConnections {
    export interface Options {
        environment?: core.Supplier<environments.AirweaveSDKEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    }
}

/**
 * API endpoints for managing live connections to data sources. Source connections are the actual configured instances that Airweave uses to sync data from your apps and databases, transforming it into searchable, structured information within collections
 */
export class SourceConnections {
    protected readonly _options: SourceConnections.Options;

    constructor(_options: SourceConnections.Options) {
        this._options = _options;
    }

    /**
     * Retrieve all source connections for your organization.
     *
     * Returns a lightweight list of source connections with essential fields for
     * display and navigation. Use the collection filter to see connections within
     * a specific collection.
     *
     * For full connection details including sync history, use the GET /{id} endpoint.
     *
     * @param {AirweaveSDK.ListSourceConnectionsGetRequest} request
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.sourceConnections.list({
     *         collection: "collection",
     *         skip: 0,
     *         limit: 100
     *     })
     */
    public list(
        request: AirweaveSDK.ListSourceConnectionsGetRequest = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnectionListItem[]> {
        return core.HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
    }

    private async __list(
        request: AirweaveSDK.ListSourceConnectionsGetRequest = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnectionListItem[]>> {
        const { collection, skip, limit } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (collection != null) {
            _queryParams["collection"] = collection;
        }

        if (skip != null) {
            _queryParams["skip"] = skip.toString();
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                "source-connections",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as AirweaveSDK.SourceConnectionListItem[],
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError("Timeout exceeded when calling GET /source-connections.");
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new source connection to sync data from an external source.
     *
     * The authentication method determines the creation flow:
     *
     * - **Direct**: Provide credentials (API key, token) directly. Connection is created immediately.
     * - **OAuth Browser**: Returns a connection with an `auth_url` to redirect users for authentication.
     * - **OAuth Token**: Provide an existing OAuth token. Connection is created immediately.
     * - **Auth Provider**: Use a pre-configured auth provider (e.g., Composio, Pipedream).
     *
     * After successful authentication, data sync can begin automatically or on-demand.
     *
     * @param {AirweaveSDK.SourceConnectionCreate} request
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.sourceConnections.create({
     *         short_name: "github",
     *         readable_collection_id: "customer-support-tickets-x7k9m"
     *     })
     */
    public create(
        request: AirweaveSDK.SourceConnectionCreate,
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnection> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: AirweaveSDK.SourceConnectionCreate,
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnection>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                "source-connections",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnection, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError("Timeout exceeded when calling POST /source-connections.");
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve details of a specific source connection.
     *
     * Returns complete information about the connection including:
     * - Configuration settings
     * - Authentication status
     * - Sync schedule and history
     * - Entity statistics
     *
     * @param {string} sourceConnectionId - Unique identifier of the source connection (UUID)
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.sourceConnections.get("550e8400-e29b-41d4-a716-446655440000")
     */
    public get(
        sourceConnectionId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnection> {
        return core.HttpResponsePromise.fromPromise(this.__get(sourceConnectionId, requestOptions));
    }

    private async __get(
        sourceConnectionId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnection>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnection, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling GET /source-connections/{source_connection_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Permanently delete a source connection and all its synced data.
     *
     * This operation:
     * - Removes all entities synced from this source from the vector database
     * - Cancels any scheduled or running sync jobs
     * - Deletes the connection configuration and credentials
     *
     * **Warning**: This action cannot be undone. All synced data will be permanently deleted.
     *
     * @param {string} sourceConnectionId - Unique identifier of the source connection to delete (UUID)
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.sourceConnections.delete("550e8400-e29b-41d4-a716-446655440000")
     */
    public delete(
        sourceConnectionId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnection> {
        return core.HttpResponsePromise.fromPromise(this.__delete(sourceConnectionId, requestOptions));
    }

    private async __delete(
        sourceConnectionId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnection>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnection, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling DELETE /source-connections/{source_connection_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update an existing source connection's configuration.
     *
     * You can modify:
     * - **Name and description**: Display information
     * - **Configuration**: Source-specific settings (e.g., repository name, filters)
     * - **Schedule**: Cron expression for automatic syncs
     * - **Authentication**: Update credentials (direct auth only)
     *
     * Only include the fields you want to change; omitted fields retain their current values.
     *
     * @param {string} sourceConnectionId - Unique identifier of the source connection to update (UUID)
     * @param {AirweaveSDK.SourceConnectionUpdate} request
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.sourceConnections.update("550e8400-e29b-41d4-a716-446655440000")
     */
    public update(
        sourceConnectionId: string,
        request: AirweaveSDK.SourceConnectionUpdate = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnection> {
        return core.HttpResponsePromise.fromPromise(this.__update(sourceConnectionId, request, requestOptions));
    }

    private async __update(
        sourceConnectionId: string,
        request: AirweaveSDK.SourceConnectionUpdate = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnection>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnection, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling PATCH /source-connections/{source_connection_id}.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Trigger a data synchronization job for a source connection.
     *
     * Starts an asynchronous sync job that pulls the latest data from the connected
     * source. The job runs in the background and you can monitor its progress using
     * the jobs endpoint.
     *
     * For continuous sync connections, this performs an incremental sync by default.
     * Use `force_full_sync=true` to perform a complete re-sync of all data.
     *
     * @param {string} sourceConnectionId - Unique identifier of the source connection to sync (UUID)
     * @param {AirweaveSDK.RunSourceConnectionsSourceConnectionIdRunPostRequest} request
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.ConflictError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.sourceConnections.run("550e8400-e29b-41d4-a716-446655440000", {
     *         force_full_sync: false
     *     })
     */
    public run(
        sourceConnectionId: string,
        request: AirweaveSDK.RunSourceConnectionsSourceConnectionIdRunPostRequest = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnectionJob> {
        return core.HttpResponsePromise.fromPromise(this.__run(sourceConnectionId, request, requestOptions));
    }

    private async __run(
        sourceConnectionId: string,
        request: AirweaveSDK.RunSourceConnectionsSourceConnectionIdRunPostRequest = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnectionJob>> {
        const { force_full_sync: forceFullSync } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (forceFullSync != null) {
            _queryParams["force_full_sync"] = forceFullSync.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}/run`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnectionJob, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 409:
                    throw new AirweaveSDK.ConflictError(
                        _response.error.body as AirweaveSDK.ConflictErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling POST /source-connections/{source_connection_id}/run.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve the sync job history for a source connection.
     *
     * Returns a list of sync jobs ordered by creation time (newest first). Each job
     * includes status, timing information, and entity counts.
     *
     * Job statuses:
     * - **PENDING**: Job is queued and waiting to start
     * - **RUNNING**: Sync is actively pulling and processing data
     * - **COMPLETED**: Sync finished successfully
     * - **FAILED**: Sync encountered an error
     * - **CANCELLED**: Sync was manually cancelled
     * - **CANCELLING**: Cancellation has been requested
     *
     * @param {string} sourceConnectionId - Unique identifier of the source connection (UUID)
     * @param {AirweaveSDK.GetSourceConnectionJobsSourceConnectionsSourceConnectionIdJobsGetRequest} request
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.sourceConnections.getSourceConnectionJobs("550e8400-e29b-41d4-a716-446655440000", {
     *         limit: 100
     *     })
     */
    public getSourceConnectionJobs(
        sourceConnectionId: string,
        request: AirweaveSDK.GetSourceConnectionJobsSourceConnectionsSourceConnectionIdJobsGetRequest = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnectionJob[]> {
        return core.HttpResponsePromise.fromPromise(
            this.__getSourceConnectionJobs(sourceConnectionId, request, requestOptions),
        );
    }

    private async __getSourceConnectionJobs(
        sourceConnectionId: string,
        request: AirweaveSDK.GetSourceConnectionJobsSourceConnectionsSourceConnectionIdJobsGetRequest = {},
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnectionJob[]>> {
        const { limit } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}/jobs`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnectionJob[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling GET /source-connections/{source_connection_id}/jobs.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Request cancellation of a running sync job.
     *
     * The job will be marked as CANCELLING and the sync workflow will stop at the
     * next checkpoint. Already-processed entities are retained.
     *
     * **Note**: Cancellation is asynchronous. The job status will change to CANCELLED
     * once the workflow has fully stopped.
     *
     * @param {string} sourceConnectionId - Unique identifier of the source connection (UUID)
     * @param {string} jobId - Unique identifier of the sync job to cancel (UUID)
     * @param {SourceConnections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link AirweaveSDK.NotFoundError}
     * @throws {@link AirweaveSDK.ConflictError}
     * @throws {@link AirweaveSDK.UnprocessableEntityError}
     * @throws {@link AirweaveSDK.TooManyRequestsError}
     *
     * @example
     *     await client.sourceConnections.cancelJob("550e8400-e29b-41d4-a716-446655440000", "660e8400-e29b-41d4-a716-446655440001")
     */
    public cancelJob(
        sourceConnectionId: string,
        jobId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): core.HttpResponsePromise<AirweaveSDK.SourceConnectionJob> {
        return core.HttpResponsePromise.fromPromise(this.__cancelJob(sourceConnectionId, jobId, requestOptions));
    }

    private async __cancelJob(
        sourceConnectionId: string,
        jobId: string,
        requestOptions?: SourceConnections.RequestOptions,
    ): Promise<core.WithRawResponse<AirweaveSDK.SourceConnectionJob>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.AirweaveSDKEnvironment.Production,
                `source-connections/${encodeURIComponent(sourceConnectionId)}/jobs/${encodeURIComponent(jobId)}/cancel`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as AirweaveSDK.SourceConnectionJob, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new AirweaveSDK.NotFoundError(
                        _response.error.body as AirweaveSDK.NotFoundErrorResponse,
                        _response.rawResponse,
                    );
                case 409:
                    throw new AirweaveSDK.ConflictError(
                        _response.error.body as AirweaveSDK.ConflictErrorResponse,
                        _response.rawResponse,
                    );
                case 422:
                    throw new AirweaveSDK.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 429:
                    throw new AirweaveSDK.TooManyRequestsError(
                        _response.error.body as AirweaveSDK.RateLimitErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.AirweaveSDKError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.AirweaveSDKError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.AirweaveSDKTimeoutError(
                    "Timeout exceeded when calling POST /source-connections/{source_connection_id}/jobs/{job_id}/cancel.",
                );
            case "unknown":
                throw new errors.AirweaveSDKError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | undefined>> {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
